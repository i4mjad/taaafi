import 'dart:io';

import 'package:device_info_plus/device_info_plus.dart';

import 'package:cloud_firestore/cloud_firestore.dart';

import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:reboot_app_3/features/authentication/data/models/user_document.dart';
import 'package:reboot_app_3/features/authentication/data/repositories/migeration_repository.dart';
import 'package:reboot_app_3/features/shared/models/follow_up.dart';

import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'migration_service.g.dart';

@riverpod
FirebaseFirestore firestoreInstance(ref) {
  return FirebaseFirestore.instance;
}

@riverpod
FirebaseMessaging messagingInstance(ref) {
  return FirebaseMessaging.instance;
}

@riverpod
MigrationService migrationService(ref) {
  return MigrationService(
    ref.watch(fcmRepositoryProvider),
    ref.watch(migerationRepositoryProvider),
  );
}

class MigrationService {
  final FCMRepository _fcmRepository;
  final MigerationRepository _migerationRepository;

  MigrationService(this._fcmRepository, this._migerationRepository);

  Future<void> migrateToNewDocuemntStrcture(UserDocument document) async {
    final userDoc = await _migerationRepository.getUserDocMap();

    final legacyDoc = UserDocument.fromFirestore(userDoc);

    await _migrateFollowups(
      legacyDoc.userRelapses,
      legacyDoc.userWatchingWithoutMasturbating,
      legacyDoc.userMasturbatingWithoutWatching,
    );

    await _updateUserDocument(document);
  }

  Future<void> _migrateFollowups(
    List<String>? relapses,
    List<String>? porns,
    List<String>? masts,
  ) async {
    // Convert each list to a set of DateTime strings for easy comparison
    Set<String> relapseSet = relapses?.toSet() ?? {};
    Set<String> pornSet = porns?.toSet() ?? {};
    Set<String> mastSet = masts?.toSet() ?? {};

    // Find common elements in all three lists
    Set<String> commonRelapses =
        relapseSet.intersection(pornSet).intersection(mastSet);

    // Filter out the common elements from pornSet and mastSet
    pornSet.removeAll(commonRelapses);
    mastSet.removeAll(commonRelapses);

    // Convert common elements to FollowUp with type relapse
    List<FollowUpModel> followUps = commonRelapses.map((timeString) {
      return FollowUpModel(
        id: '', // ID will be generated by Firebase
        time: DateTime.parse(timeString).toUtc(),
        type: FollowUpType.relapse,
      );
    }).toList();

    // Convert the remaining porn and mast lists to FollowUp objects
    followUps.addAll(pornSet.map((timeString) {
      return FollowUpModel(
        id: '', // ID will be generated by Firebase
        time: DateTime.parse(timeString).toUtc(),
        type: FollowUpType.pornOnly,
      );
    }).toList());

    followUps.addAll(mastSet.map((timeString) {
      return FollowUpModel(
        id: '', // ID will be generated by Firebase
        time: DateTime.parse(timeString).toUtc(),
        type: FollowUpType.mastOnly,
      );
    }).toList());

    await _migerationRepository.bulkFollowUpsInsertion(followUps);
  }

  Future<void> _updateUserDocument(UserDocument document) async {
    String fcmToken = await _fcmRepository.getMessagingToken();

    var deviceId = await _getDeviceId();

    String role = "user";
    UserDocument newDocuemnt = UserDocument(
      uid: document.uid!,
      devicesIds: [deviceId],
      displayName: document.displayName!,
      email: document.email!,
      gender: document.gender!,
      locale: document.locale!,
      dayOfBirth: document.dayOfBirth!,
      userFirstDate: document.userFirstDate!,
      role: role,
      messagingToken: fcmToken,
      bookmarkedContentIds: [],
      userRelapses: document.userRelapses,
      userWatchingWithoutMasturbating: document.userWatchingWithoutMasturbating,
      userMasturbatingWithoutWatching: document.userMasturbatingWithoutWatching,
    );

    await _migerationRepository.updateUserDocument(newDocuemnt);
  }

  Future<String> _getDeviceId() async {
    try {
      final DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();

      if (Platform.isAndroid) {
        final AndroidDeviceInfo androidInfo = await deviceInfo.androidInfo;
        if (androidInfo.id.isEmpty) {
          throw Exception('Failed to get Android device ID');
        }
        return androidInfo.id;
      }

      if (Platform.isIOS) {
        final IosDeviceInfo iosInfo = await deviceInfo.iosInfo;
        final String? vendorId = iosInfo.identifierForVendor;
        if (vendorId == null || vendorId.isEmpty) {
          throw Exception('Failed to get iOS vendor ID');
        }
        return vendorId;
      }

      throw UnsupportedError('Unsupported platform for device ID');
    } catch (e) {
      print('Error getting device ID: $e');
      // Return a fallback value or rethrow based on requirements
      return '';
    }
  }
}
