import 'dart:developer' as developer;
import '../repositories/updates_repository.dart';
import '../entities/group_update_entity.dart';
import '../entities/update_comment_entity.dart';
import 'followup_integration_service.dart';
import 'update_preset_templates.dart';
import 'package:reboot_app_3/features/shared/models/follow_up.dart';

/// Service for managing group updates with business logic
class UpdatesService {
  final UpdatesRepository _repository;
  final FollowupIntegrationService _followupService;

  UpdatesService(
    this._repository,
    this._followupService,
  );

  void log(String message, {StackTrace? stackTrace}) {
    developer.log(
      message,
      name: 'UpdatesService',
      stackTrace: stackTrace,
    );
  }

  // ==================== POST UPDATE ====================

  /// Post a new update to the group
  Future<PostUpdateResult> postUpdate({
    required String groupId,
    required String authorCpId,
    required UpdateType type,
    required String title,
    required String content,
    String? linkedFollowupId,
    String? linkedChallengeId,
    String? linkedMilestoneId,
    bool isAnonymous = false,
    UpdateVisibility visibility = UpdateVisibility.membersOnly,
  }) async {
    try {
      log('Posting update to group $groupId by user $authorCpId');

      // Validate inputs
      if (title.length > 100) {
        return PostUpdateResult.failure('Title must be 100 characters or less');
      }
      if (content.length > 1000) {
        return PostUpdateResult.failure(
          'Content must be 1000 characters or less',
        );
      }
      if (content.trim().isEmpty) {
        return PostUpdateResult.failure('Content cannot be empty');
      }

      // Create update entity
      final update = GroupUpdateEntity(
        id: '', // Will be generated by repository
        groupId: groupId,
        authorCpId: authorCpId,
        type: type,
        title: title,
        content: content,
        linkedFollowupId: linkedFollowupId,
        linkedChallengeId: linkedChallengeId,
        linkedMilestoneId: linkedMilestoneId,
        isAnonymous: isAnonymous,
        visibility: visibility,
        reactions: {},
        commentCount: 0,
        supportCount: 0,
        isPinned: false,
        isHidden: false,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      final updateId = await _repository.createUpdate(update);

      log('Update posted successfully: $updateId');
      return PostUpdateResult.success(updateId);
    } catch (e, stackTrace) {
      log('Error posting update: $e', stackTrace: stackTrace);
      return PostUpdateResult.failure('Failed to post update: $e');
    }
  }

  /// Create update from a followup entry
  Future<PostUpdateResult> createUpdateFromFollowup({
    required String groupId,
    required String authorCpId,
    required FollowUpModel followup,
    bool isAnonymous = false,
  }) async {
    try {
      log('Creating update from followup: ${followup.id}');

      // Generate content from followup
      final updateContent =
          _followupService.generateUpdateContentFromFollowup(followup);

      return await postUpdate(
        groupId: groupId,
        authorCpId: authorCpId,
        type: updateContent.type,
        title: updateContent.title,
        content: updateContent.content,
        linkedFollowupId: followup.id,
        isAnonymous: isAnonymous,
      );
    } catch (e, stackTrace) {
      log('Error creating update from followup: $e', stackTrace: stackTrace);
      return PostUpdateResult.failure('Failed to create update from followup');
    }
  }

  /// Create update from a preset template
  Future<PostUpdateResult> createUpdateFromPreset({
    required String groupId,
    required String authorCpId,
    required String presetId,
    String? additionalContent,
    bool isAnonymous = false,
  }) async {
    try {
      log('Creating update from preset: $presetId');

      final preset = UpdatePresetTemplates.getPresetById(presetId);
      if (preset == null) {
        return PostUpdateResult.failure('Preset not found');
      }

      // Use preset content or add additional content if provided
      final content = additionalContent?.isNotEmpty == true
          ? '${preset.contentKey}\n\n$additionalContent'
          : preset.contentKey;

      return await postUpdate(
        groupId: groupId,
        authorCpId: authorCpId,
        type: preset.type,
        title: preset.titleKey,
        content: content,
        isAnonymous: isAnonymous,
      );
    } catch (e, stackTrace) {
      log('Error creating update from preset: $e', stackTrace: stackTrace);
      return PostUpdateResult.failure('Failed to create update from preset');
    }
  }

  /// Create milestone update (linked to achievement)
  Future<PostUpdateResult> createMilestoneUpdate({
    required String groupId,
    required String authorCpId,
    required String milestoneId,
    required String milestoneName,
    String? additionalMessage,
    bool isAnonymous = false,
  }) async {
    try {
      log('Creating milestone update for: $milestoneName');

      final content = additionalMessage?.isNotEmpty == true
          ? 'milestone-update-content-with-message'
          : 'milestone-update-content';

      return await postUpdate(
        groupId: groupId,
        authorCpId: authorCpId,
        type: UpdateType.milestone,
        title: 'milestone-update-title',
        content: content,
        linkedMilestoneId: milestoneId,
        isAnonymous: isAnonymous,
      );
    } catch (e, stackTrace) {
      log('Error creating milestone update: $e', stackTrace: stackTrace);
      return PostUpdateResult.failure('Failed to create milestone update');
    }
  }

  // ==================== AUTO-SUGGEST UPDATES ====================

  /// Get suggested updates for a user based on their activity
  Future<List<UpdateSuggestion>> getSuggestedUpdates(
    String cpId,
    String groupId,
  ) async {
    try {
      log('Getting suggested updates for user $cpId in group $groupId');

      final suggestions = <UpdateSuggestion>[];

      // Get recent followups
      final recentFollowups = await _followupService.getRecentFollowups(cpId);
      
      // Suggest sharing recent followups (if not already shared)
      for (final followup in recentFollowups.take(3)) {
        if (!_followupService.canShareFollowupType(followup.type)) continue;

        final isShared = await _followupService.isFollowupShared(
          followup.id,
          groupId,
        );
        
        if (!isShared) {
          suggestions.add(
            UpdateSuggestion(
              type: SuggestionType.fromFollowup,
              title: 'suggestion-share-followup-title',
              description: 'suggestion-share-followup-desc',
              followupId: followup.id,
            ),
          );
        }
      }

      // Suggest check-in if user hasn't posted in a while
      final userUpdates = await _repository.getUserUpdates(
        groupId,
        cpId,
        limit: 1,
      );
      
      if (userUpdates.isEmpty) {
        suggestions.add(
          UpdateSuggestion(
            type: SuggestionType.firstUpdate,
            title: 'suggestion-first-update-title',
            description: 'suggestion-first-update-desc',
          ),
        );
      } else {
        final lastUpdate = userUpdates.first;
        final daysSinceLastUpdate =
            DateTime.now().difference(lastUpdate.createdAt).inDays;
        
        if (daysSinceLastUpdate >= 7) {
          suggestions.add(
            UpdateSuggestion(
              type: SuggestionType.weeklyCheckin,
              title: 'suggestion-weekly-checkin-title',
              description: 'suggestion-weekly-checkin-desc',
            ),
          );
        }
      }

      log('Found ${suggestions.length} suggestions');
      return suggestions;
    } catch (e, stackTrace) {
      log('Error getting suggested updates: $e', stackTrace: stackTrace);
      return [];
    }
  }

  // ==================== ENGAGEMENT ====================

  /// React to an update
  Future<void> reactToUpdate(
    String updateId,
    String cpId,
    String emoji,
  ) async {
    try {
      log('User $cpId reacting to update $updateId with $emoji');
      await _repository.toggleUpdateReaction(updateId, cpId, emoji);
    } catch (e, stackTrace) {
      log('Error reacting to update: $e', stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Comment on an update
  Future<String> commentOnUpdate({
    required String updateId,
    required String groupId,
    required String authorCpId,
    required String content,
    bool isAnonymous = false,
  }) async {
    try {
      log('User $authorCpId commenting on update $updateId');

      // Validate
      if (content.trim().isEmpty) {
        throw Exception('Comment cannot be empty');
      }
      if (content.length > 500) {
        throw Exception('Comment must be 500 characters or less');
      }

      final comment = UpdateCommentEntity(
        id: '', // Will be generated by repository
        updateId: updateId,
        groupId: groupId,
        authorCpId: authorCpId,
        content: content,
        isAnonymous: isAnonymous,
        isHidden: false,
        reactions: {},
        createdAt: DateTime.now(),
      );

      final commentId = await _repository.addComment(comment);
      log('Comment added successfully: $commentId');
      return commentId;
    } catch (e, stackTrace) {
      log('Error commenting on update: $e', stackTrace: stackTrace);
      rethrow;
    }
  }

  /// React to a comment
  Future<void> reactToComment(
    String commentId,
    String cpId,
    String emoji,
  ) async {
    try {
      log('User $cpId reacting to comment $commentId with $emoji');
      await _repository.toggleCommentReaction(commentId, cpId, emoji);
    } catch (e, stackTrace) {
      log('Error reacting to comment: $e', stackTrace: stackTrace);
      rethrow;
    }
  }

  // ==================== UPDATE MANAGEMENT ====================

  /// Edit an update (owner only)
  Future<void> editUpdate({
    required String updateId,
    required String cpId,
    String? newTitle,
    String? newContent,
  }) async {
    try {
      log('User $cpId editing update $updateId');

      final update = await _repository.getUpdateById(updateId);
      if (update == null) {
        throw Exception('Update not found');
      }

      if (!update.canEdit(cpId)) {
        throw Exception('You do not have permission to edit this update');
      }

      final updatedUpdate = update.copyWith(
        title: newTitle ?? update.title,
        content: newContent ?? update.content,
        updatedAt: DateTime.now(),
      );

      await _repository.updateUpdate(updatedUpdate);
      log('Update edited successfully');
    } catch (e, stackTrace) {
      log('Error editing update: $e', stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Delete an update (owner or admin)
  Future<void> deleteUpdate(
    String updateId,
    String cpId,
    bool isAdmin,
  ) async {
    try {
      log('User $cpId deleting update $updateId (admin: $isAdmin)');

      final update = await _repository.getUpdateById(updateId);
      if (update == null) {
        throw Exception('Update not found');
      }

      if (!update.canDelete(cpId, isAdmin)) {
        throw Exception('You do not have permission to delete this update');
      }

      await _repository.deleteUpdate(updateId);
      log('Update deleted successfully');
    } catch (e, stackTrace) {
      log('Error deleting update: $e', stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Delete a comment (owner or admin)
  Future<void> deleteComment({
    required String commentId,
    required String updateId,
    required String cpId,
    required bool isAdmin,
  }) async {
    try {
      log('User $cpId deleting comment $commentId (admin: $isAdmin)');

      // Note: In production, you'd want to check permissions here
      // For now, we'll trust the isAdmin flag

      await _repository.deleteComment(commentId, updateId);
      log('Comment deleted successfully');
    } catch (e, stackTrace) {
      log('Error deleting comment: $e', stackTrace: stackTrace);
      rethrow;
    }
  }
}

// ==================== RESULT CLASSES ====================

/// Result of posting an update
class PostUpdateResult {
  final bool success;
  final String? updateId;
  final String? errorMessage;

  const PostUpdateResult._({
    required this.success,
    this.updateId,
    this.errorMessage,
  });

  factory PostUpdateResult.success(String updateId) {
    return PostUpdateResult._(success: true, updateId: updateId);
  }

  factory PostUpdateResult.failure(String errorMessage) {
    return PostUpdateResult._(success: false, errorMessage: errorMessage);
  }
}

/// Suggested update for user
class UpdateSuggestion {
  final SuggestionType type;
  final String title; // Localization key
  final String description; // Localization key
  final String? followupId;
  final String? challengeId;

  const UpdateSuggestion({
    required this.type,
    required this.title,
    required this.description,
    this.followupId,
    this.challengeId,
  });
}

/// Type of suggestion
enum SuggestionType {
  fromFollowup,
  firstUpdate,
  weeklyCheckin,
  challengeProgress,
  milestone,
}

