import 'dart:developer';
import '../entities/challenge_entity.dart';
import '../entities/challenge_participation_entity.dart';
import '../entities/challenge_stats_entity.dart';
import '../entities/challenge_result_entities.dart';
import '../entities/challenge_update_entity.dart';
import '../repositories/challenges_repository.dart';

/// Service for challenge business logic
///
/// Handles validation, orchestration, and business rules for challenges
class ChallengesService {
  final ChallengesRepository _repository;

  const ChallengesService(this._repository);

  // ============================================
  // Challenge Management
  // ============================================

  /// Create a new challenge with validation
  Future<CreateChallengeResult> createChallenge({
    required String groupId,
    required String creatorCpId,
    required String title,
    required String description,
    required ChallengeType type,
    required DateTime startDate,
    required DateTime endDate,
    int? durationDays,
    GoalType? goalType,
    int? goalTarget,
    String? goalUnit,
    int? maxParticipants,
    bool allowLateJoin = true,
    bool notifyOnMilestone = true,
    int pointsReward = 0,
  }) async {
    try {
      // Validation: Title
      if (title.trim().isEmpty) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidTitle,
          'Title cannot be empty',
        );
      }
      if (title.length > 60) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidTitle,
          'Title must be 60 characters or less',
        );
      }

      // Validation: Description
      if (description.trim().isEmpty) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidDescription,
          'Description cannot be empty',
        );
      }
      if (description.length > 500) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidDescription,
          'Description must be 500 characters or less',
        );
      }

      // Validation: Dates
      if (endDate.isBefore(startDate)) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidDates,
          'End date must be after start date',
        );
      }

      final now = DateTime.now();
      if (startDate.isBefore(now.subtract(const Duration(days: 1)))) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidDates,
          'Start date cannot be in the past',
        );
      }

      // Calculate duration if not provided
      final calculatedDuration =
          durationDays ?? endDate.difference(startDate).inDays;

      // Validation: Goal (for goal-based challenges)
      if (type == ChallengeType.goal || type == ChallengeType.team) {
        if (goalType == null || goalTarget == null || goalTarget <= 0) {
          return const CreateChallengeResult.failure(
            CreateChallengeError.invalidGoal,
            'Goal type and target are required for goal-based challenges',
          );
        }
      }

      // Create challenge entity
      final challenge = ChallengeEntity(
        id: '', // Will be generated by Firestore
        groupId: groupId,
        title: title.trim(),
        description: description.trim(),
        type: type,
        startDate: startDate,
        endDate: endDate,
        durationDays: calculatedDuration,
        goalType: goalType,
        goalTarget: goalTarget,
        goalUnit: goalUnit,
        maxParticipants: maxParticipants,
        status: ChallengeStatus.active,
        createdBy: creatorCpId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        allowLateJoin: allowLateJoin,
        notifyOnMilestone: notifyOnMilestone,
        pointsReward: pointsReward,
      );

      // Save to repository
      final challengeId = await _repository.createChallenge(challenge);

      return CreateChallengeResult.success(challengeId);
    } catch (e, stackTrace) {
      log('Error in createChallenge service: $e', stackTrace: stackTrace);
      return const CreateChallengeResult.failure(
        CreateChallengeError.unknown,
        'Failed to create challenge',
      );
    }
  }

  /// Join a challenge with validation
  Future<JoinChallengeResult> joinChallenge({
    required String challengeId,
    required String cpId,
  }) async {
    try {
      // Get challenge
      final challenge = await _repository.getChallengeById(challengeId);
      if (challenge == null) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.challengeNotFound,
          'Challenge not found',
        );
      }

      // Check if challenge is active
      if (challenge.status != ChallengeStatus.active) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.challengeNotActive,
          'Challenge is not active',
        );
      }

      // Check if already participating
      final existingParticipation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );
      if (existingParticipation != null) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.alreadyJoined,
          'Already participating in this challenge',
        );
      }

      // Check if challenge is full
      if (challenge.isFull()) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.challengeFull,
          'Challenge is at maximum capacity',
        );
      }

      // Check if late join is allowed
      if (challenge.hasStarted() && !challenge.allowLateJoin) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.lateJoinNotAllowed,
          'Late joining is not allowed for this challenge',
        );
      }

      // Determine goal value
      final goalValue = challenge.goalTarget ?? challenge.durationDays;

      // Join challenge
      final participationId = await _repository.joinChallenge(
        challengeId: challengeId,
        cpId: cpId,
        groupId: challenge.groupId,
        goalValue: goalValue,
      );

      return JoinChallengeResult.success(participationId);
    } catch (e, stackTrace) {
      log('Error in joinChallenge service: $e', stackTrace: stackTrace);
      return const JoinChallengeResult.failure(
        JoinChallengeError.unknown,
        'Failed to join challenge',
      );
    }
  }

  /// Leave a challenge
  Future<LeaveChallengeResult> leaveChallenge({
    required String challengeId,
    required String cpId,
  }) async {
    try {
      // Check if participating
      final participation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );

      if (participation == null) {
        return const LeaveChallengeResult.failure(
          LeaveChallengeError.notParticipating,
          'Not participating in this challenge',
        );
      }

      if (participation.isCompleted()) {
        return const LeaveChallengeResult.failure(
          LeaveChallengeError.challengeCompleted,
          'Cannot leave a completed challenge',
        );
      }

      // Leave challenge
      await _repository.leaveChallenge(
        challengeId: challengeId,
        cpId: cpId,
      );

      return const LeaveChallengeResult.success();
    } catch (e, stackTrace) {
      log('Error in leaveChallenge service: $e', stackTrace: stackTrace);
      return const LeaveChallengeResult.failure(
        LeaveChallengeError.unknown,
        'Failed to leave challenge',
      );
    }
  }

  /// Update progress for a participant
  Future<UpdateProgressResult> updateProgress({
    required String challengeId,
    required String cpId,
    required int newValue,
    String? note,
  }) async {
    try {
      // Get participation
      final participation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );

      if (participation == null) {
        return const UpdateProgressResult.failure(
          UpdateProgressError.notParticipating,
          'Not participating in this challenge',
        );
      }

      // Check if can update progress
      if (!participation.canUpdateProgress()) {
        return const UpdateProgressResult.failure(
          UpdateProgressError.challengeNotActive,
          'Challenge is not active',
        );
      }

      // Validate new value
      if (newValue < participation.currentValue) {
        return const UpdateProgressResult.failure(
          UpdateProgressError.invalidValue,
          'New value must be greater than current value',
        );
      }

      if (newValue > participation.goalValue) {
        return const UpdateProgressResult.failure(
          UpdateProgressError.invalidValue,
          'New value cannot exceed goal value',
        );
      }

      // Calculate new progress percentage
      final newProgress = ((newValue / participation.goalValue) * 100).round();

      // Update progress
      await _repository.updateProgress(
        challengeId: challengeId,
        cpId: cpId,
        newCurrentValue: newValue,
        newProgress: newProgress,
      );

      // Check if completed
      bool isCompleted = false;
      if (newProgress >= 100) {
        await _repository.completeParticipation(
          challengeId: challengeId,
          cpId: cpId,
        );
        isCompleted = true;
      }

      // Detect milestone
      int? milestone;
      final oldProgress = participation.progress;
      if (oldProgress < 25 && newProgress >= 25) {
        milestone = 25;
      } else if (oldProgress < 50 && newProgress >= 50) {
        milestone = 50;
      } else if (oldProgress < 75 && newProgress >= 75) {
        milestone = 75;
      } else if (newProgress >= 100) {
        milestone = 100;
      }

      // Create update entry if there's a milestone or note
      if (milestone != null || note != null) {
        final updateType = milestone != null
            ? ChallengeUpdateType.milestone
            : ChallengeUpdateType.progress;

        final message = note ??
            (milestone != null ? 'Reached $milestone%!' : 'Updated progress');

        await _repository.createChallengeUpdate(
          ChallengeUpdateEntity(
            id: '',
            challengeId: challengeId,
            cpId: cpId,
            type: updateType,
            message: message,
            value: newValue,
            createdAt: DateTime.now(),
          ),
        );
      }

      return UpdateProgressResult.success(
        newProgress: newProgress,
        newCurrentValue: newValue,
        isCompleted: isCompleted,
        milestoneReached: milestone,
      );
    } catch (e, stackTrace) {
      log('Error in updateProgress service: $e', stackTrace: stackTrace);
      return const UpdateProgressResult.failure(
        UpdateProgressError.unknown,
        'Failed to update progress',
      );
    }
  }

  /// Delete a challenge (admin only)
  Future<DeleteChallengeResult> deleteChallenge({
    required String challengeId,
    required String requestingCpId,
  }) async {
    try {
      // Get challenge
      final challenge = await _repository.getChallengeById(challengeId);
      if (challenge == null) {
        return const DeleteChallengeResult.failure(
          DeleteChallengeError.challengeNotFound,
          'Challenge not found',
        );
      }

      // Check authorization (only creator can delete)
      if (challenge.createdBy != requestingCpId) {
        return const DeleteChallengeResult.failure(
          DeleteChallengeError.notAuthorized,
          'Only the challenge creator can delete it',
        );
      }

      // Delete challenge
      await _repository.deleteChallenge(challengeId);

      return const DeleteChallengeResult.success();
    } catch (e, stackTrace) {
      log('Error in deleteChallenge service: $e', stackTrace: stackTrace);
      return const DeleteChallengeResult.failure(
        DeleteChallengeError.unknown,
        'Failed to delete challenge',
      );
    }
  }

  // ============================================
  // Query Methods (pass-through to repository)
  // ============================================

  Future<ChallengeEntity?> getChallengeById(String challengeId) async {
    return await _repository.getChallengeById(challengeId);
  }

  Future<List<ChallengeEntity>> getGroupChallenges(String groupId) async {
    return await _repository.getGroupChallenges(groupId);
  }

  Future<List<ChallengeEntity>> getActiveChallenges(String groupId) async {
    return await _repository.getActiveChallenges(groupId);
  }

  Future<List<ChallengeEntity>> getCompletedChallenges(String groupId) async {
    return await _repository.getCompletedChallenges(groupId);
  }

  Future<ChallengeParticipationEntity?> getParticipation({
    required String challengeId,
    required String cpId,
  }) async {
    return await _repository.getParticipation(
      challengeId: challengeId,
      cpId: cpId,
    );
  }

  Future<List<ChallengeParticipationEntity>> getLeaderboard({
    required String challengeId,
    int limit = 10,
  }) async {
    return await _repository.getLeaderboard(
      challengeId: challengeId,
      limit: limit,
    );
  }

  Future<ChallengeStatsEntity> getChallengeStats(String challengeId) async {
    return await _repository.getChallengeStats(challengeId);
  }

  Future<List<ChallengeUpdateEntity>> getChallengeUpdates({
    required String challengeId,
    int limit = 20,
  }) async {
    return await _repository.getChallengeUpdates(
      challengeId: challengeId,
      limit: limit,
    );
  }

  Future<List<ChallengeParticipationEntity>> getUserActiveChallenges(
    String cpId,
  ) async {
    return await _repository.getUserActiveChallenges(cpId);
  }
}

