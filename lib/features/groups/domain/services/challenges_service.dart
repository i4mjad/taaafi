import 'dart:developer';
import '../entities/challenge_entity.dart';
import '../entities/challenge_participation_entity.dart';
import '../entities/challenge_stats_entity.dart';
import '../entities/challenge_result_entities.dart';
import '../entities/challenge_update_entity.dart';
import '../repositories/challenges_repository.dart';
import '../repositories/groups_repository.dart';

/// Service for challenge business logic
///
/// Handles validation, orchestration, and business rules for challenges
class ChallengesService {
  final ChallengesRepository _repository;
  final GroupsRepository _groupsRepository;

  const ChallengesService(this._repository, this._groupsRepository);

  // ============================================
  // Challenge Management
  // ============================================

  /// Create a new challenge with validation
  Future<CreateChallengeResult> createChallenge({
    required String groupId,
    required String creatorCpId,
    required String name,
    required DateTime endDate,
    required String color,
    required List<ChallengeTaskEntity> tasks,
  }) async {
    try {
      // Authorization: Check if creator is admin
      final membership = await _groupsRepository.getCurrentMembership(creatorCpId);
      if (membership == null || membership.groupId != groupId) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.notGroupMember,
          'You must be a member of this group',
        );
      }

      if (membership.role != 'admin') {
        return const CreateChallengeResult.failure(
          CreateChallengeError.notAuthorized,
          'Only group admins can create challenges',
        );
      }

      // Validation: Name
      if (name.trim().isEmpty) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidTitle,
          'Challenge name cannot be empty',
        );
      }
      if (name.length > 60) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidTitle,
          'Challenge name must be 60 characters or less',
        );
      }

      // Validation: End Date
      final now = DateTime.now();
      if (endDate.isBefore(now)) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidDates,
          'End date must be in the future',
        );
      }

      // Validation: Tasks
      if (tasks.isEmpty) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidGoal,
          'Challenge must have at least one task',
        );
      }

      // Validation: Color
      const validColors = ['yellow', 'coral', 'blue', 'teal'];
      if (!validColors.contains(color)) {
        return const CreateChallengeResult.failure(
          CreateChallengeError.invalidGoal,
          'Invalid color selected',
        );
      }

      // Create challenge entity
      final challenge = ChallengeEntity(
        id: '', // Will be generated by Firestore
        groupId: groupId,
        name: name.trim(),
        endDate: endDate,
        color: color,
        tasks: tasks,
        status: ChallengeStatus.active,
        createdBy: creatorCpId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Save to repository
      final challengeId = await _repository.createChallenge(challenge);

      return CreateChallengeResult.success(challengeId);
    } catch (e, stackTrace) {
      log('Error in createChallenge service: $e', stackTrace: stackTrace);
      return const CreateChallengeResult.failure(
        CreateChallengeError.unknown,
        'Failed to create challenge',
      );
    }
  }

  /// Join a challenge with validation
  Future<JoinChallengeResult> joinChallenge({
    required String challengeId,
    required String cpId,
  }) async {
    try {
      // Get challenge
      final challenge = await _repository.getChallengeById(challengeId);
      if (challenge == null) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.challengeNotFound,
          'Challenge not found',
        );
      }

      // Check if challenge is active
      if (challenge.status != ChallengeStatus.active) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.challengeNotActive,
          'Challenge is not active',
        );
      }

      // Check if already participating
      final existingParticipation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );
      if (existingParticipation != null) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.alreadyJoined,
          'Already participating in this challenge',
        );
      }

      // Check if challenge is full
      if (challenge.isFull()) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.challengeFull,
          'Challenge is at maximum capacity',
        );
      }

      // Check if late join is allowed
      if (challenge.hasStarted() && !challenge.allowLateJoin) {
        return const JoinChallengeResult.failure(
          JoinChallengeError.lateJoinNotAllowed,
          'Late joining is not allowed for this challenge',
        );
      }

      // Join challenge
      final participationId = await _repository.joinChallenge(
        challengeId: challengeId,
        cpId: cpId,
        groupId: challenge.groupId,
      );

      return JoinChallengeResult.success(participationId);
    } catch (e, stackTrace) {
      log('Error in joinChallenge service: $e', stackTrace: stackTrace);
      return const JoinChallengeResult.failure(
        JoinChallengeError.unknown,
        'Failed to join challenge',
      );
    }
  }

  /// Leave a challenge
  Future<LeaveChallengeResult> leaveChallenge({
    required String challengeId,
    required String cpId,
  }) async {
    try {
      // Check if participating
      final participation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );

      if (participation == null) {
        return const LeaveChallengeResult.failure(
          LeaveChallengeError.notParticipating,
          'Not participating in this challenge',
        );
      }

      if (participation.isCompleted()) {
        return const LeaveChallengeResult.failure(
          LeaveChallengeError.challengeCompleted,
          'Cannot leave a completed challenge',
        );
      }

      // Leave challenge
      await _repository.leaveChallenge(
        challengeId: challengeId,
        cpId: cpId,
      );

      return const LeaveChallengeResult.success();
    } catch (e, stackTrace) {
      log('Error in leaveChallenge service: $e', stackTrace: stackTrace);
      return const LeaveChallengeResult.failure(
        LeaveChallengeError.unknown,
        'Failed to leave challenge',
      );
    }
  }

  /// Complete a task and award points
  Future<UpdateProgressResult> completeTask({
    required String challengeId,
    required String cpId,
    required String taskId,
    required int pointsEarned,
  }) async {
    try {
      // Get participation
      final participation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );

      if (participation == null) {
        return const UpdateProgressResult.failure(
          UpdateProgressError.notParticipating,
          'Not participating in this challenge',
        );
      }

      // Check if task already completed
      if (participation.hasCompletedTask(taskId)) {
        return const UpdateProgressResult.failure(
          UpdateProgressError.invalidValue,
          'Task already completed',
        );
      }

      // Complete task
      await _repository.completeTask(
        challengeId: challengeId,
        cpId: cpId,
        taskId: taskId,
        pointsEarned: pointsEarned,
      );

      // Get updated participation
      final updatedParticipation = await _repository.getParticipation(
        challengeId: challengeId,
        cpId: cpId,
      );

      // Check if all tasks are now completed
      final challenge = await _repository.getChallengeById(challengeId);
      if (challenge != null && updatedParticipation != null) {
        final allTasksCompleted =
            updatedParticipation.completedTaskIds.length == challenge.tasks.length;

        if (allTasksCompleted) {
          await _repository.completeParticipation(
            challengeId: challengeId,
            cpId: cpId,
          );
        }
      }

      return UpdateProgressResult.success(
        newProgress: updatedParticipation?.earnedPoints ?? 0,
        newCurrentValue: updatedParticipation?.earnedPoints ?? 0,
        isCompleted: updatedParticipation?.isCompleted() ?? false,
      );
    } catch (e, stackTrace) {
      log('Error in completeTask service: $e', stackTrace: stackTrace);
      return const UpdateProgressResult.failure(
        UpdateProgressError.unknown,
        'Failed to complete task',
      );
    }
  }

  /// Delete a challenge (admin only)
  Future<DeleteChallengeResult> deleteChallenge({
    required String challengeId,
    required String requestingCpId,
  }) async {
    try {
      // Get challenge
      final challenge = await _repository.getChallengeById(challengeId);
      if (challenge == null) {
        return const DeleteChallengeResult.failure(
          DeleteChallengeError.challengeNotFound,
          'Challenge not found',
        );
      }

      // Check authorization (only creator can delete)
      if (challenge.createdBy != requestingCpId) {
        return const DeleteChallengeResult.failure(
          DeleteChallengeError.notAuthorized,
          'Only the challenge creator can delete it',
        );
      }

      // Delete challenge
      await _repository.deleteChallenge(challengeId);

      return const DeleteChallengeResult.success();
    } catch (e, stackTrace) {
      log('Error in deleteChallenge service: $e', stackTrace: stackTrace);
      return const DeleteChallengeResult.failure(
        DeleteChallengeError.unknown,
        'Failed to delete challenge',
      );
    }
  }

  // ============================================
  // Query Methods (pass-through to repository)
  // ============================================

  Future<ChallengeEntity?> getChallengeById(String challengeId) async {
    return await _repository.getChallengeById(challengeId);
  }

  Future<List<ChallengeEntity>> getGroupChallenges(String groupId) async {
    return await _repository.getGroupChallenges(groupId);
  }

  Future<List<ChallengeEntity>> getActiveChallenges(String groupId) async {
    return await _repository.getActiveChallenges(groupId);
  }

  Future<List<ChallengeEntity>> getCompletedChallenges(String groupId) async {
    return await _repository.getCompletedChallenges(groupId);
  }

  Future<ChallengeParticipationEntity?> getParticipation({
    required String challengeId,
    required String cpId,
  }) async {
    return await _repository.getParticipation(
      challengeId: challengeId,
      cpId: cpId,
    );
  }

  Future<List<ChallengeParticipationEntity>> getLeaderboard({
    required String challengeId,
    int limit = 10,
  }) async {
    return await _repository.getLeaderboard(
      challengeId: challengeId,
      limit: limit,
    );
  }

  Future<ChallengeStatsEntity> getChallengeStats(String challengeId) async {
    return await _repository.getChallengeStats(challengeId);
  }

  Future<List<ChallengeUpdateEntity>> getChallengeUpdates({
    required String challengeId,
    int limit = 20,
  }) async {
    return await _repository.getChallengeUpdates(
      challengeId: challengeId,
      limit: limit,
    );
  }

  Future<List<ChallengeParticipationEntity>> getUserActiveChallenges(
    String cpId,
  ) async {
    return await _repository.getUserActiveChallenges(cpId);
  }
}

